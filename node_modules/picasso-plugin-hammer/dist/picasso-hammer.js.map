{"version":3,"file":"picasso-hammer.js","sources":["../src/hammer.js","../src/index.js"],"sourcesContent":["const translateKnownTypes = {\n  click: 'Tap',\n  Click: 'Tap',\n  tap: 'Tap',\n  pan: 'Pan',\n  swipe: 'Swipe',\n  rotate: 'Rotate',\n  press: 'Press',\n  pinch: 'Pinch'\n};\n\n/**\n * Helper function for translating typical non-hammer gesture to a hammer gesture. Currently only supporting 'click'\n * @param {String} type Gesture type\n * @private\n */\nfunction getGestureType(type) {\n  return translateKnownTypes[type] || type;\n}\n\n/**\n * Manages event handlers for HammerJS. Assumes Hammer is loaded and added to the global namespace\n */\nfunction hammer(chart, mediator, element) {\n  let settings;\n  let instance;\n  let mc;\n  let key;\n  let hammerGestures = [];\n  let isOn = true;\n  /**\n   * Set default settings\n   * @private\n   */\n  function setDefaultSettings(newSettings) {\n    key = newSettings.key;\n    settings = newSettings;\n    instance = { chart, mediator, settings };\n    settings.gestures = settings.gestures || [];\n    if (settings.enable === undefined) {\n      settings.enable = true;\n    }\n  }\n\n  /**\n   * @private\n   * add hammer recognizers based on settings\n   */\n  function addRecognizers() {\n    if (typeof settings.enable === 'function') {\n      settings.enable = settings.enable.bind(instance)();\n    }\n    if (!settings.enable) {\n      return; // interaction is disabled\n    }\n    settings.gestures.forEach((gesture) => {\n      gesture.options = gesture.options || {};\n      // handle action enable\n      if (gesture.options.enable === undefined) {\n        gesture.options.enable = true;\n      }\n      if (typeof gesture.options.enable === 'function') {\n        gesture.options.enable = gesture.options.enable.bind(instance);\n      }\n      // setup hammer gestures\n      const type = getGestureType(gesture.type);\n      if (Hammer && Hammer[type]) {\n        gesture.options.event = gesture.options.event || gesture.type.toLowerCase();\n        mc = mc || new Hammer.Manager(element);\n        mc.add(new Hammer[type](gesture.options));\n        Object.keys(gesture.events).forEach((eventName) => {\n          gesture.events[eventName] = gesture.events[eventName].bind(instance);\n          mc.on(eventName, gesture.events[eventName]);\n        });\n        hammerGestures.push(gesture);\n      }\n    });\n\n    // setup mixing hammer gestures\n    settings.gestures.forEach((gesture) => {\n      const type = getGestureType(gesture.type);\n      if (Hammer && Hammer[type]) {\n        if (gesture.recognizeWith) {\n          mc.get(gesture.options.event).recognizeWith(gesture.recognizeWith.split(' ').filter(e => e !== ''));\n        }\n        if (gesture.requireFailure) {\n          mc.get(gesture.options.event).requireFailure(gesture.requireFailure.split(' ').filter(e => e !== ''));\n        }\n      }\n    });\n  }\n  /**\n   * @private\n   * removes all added hammer recognizers and native events\n   */\n  function removeAddedEvents() {\n    // remove hammer recognizers and registered events\n    hammerGestures.forEach((gesture) => {\n      Object.keys(gesture.events).forEach((eventName) => {\n        mc.off(eventName, gesture.events[eventName]);\n      });\n      mc.remove(gesture.options.event);\n    });\n    hammerGestures = [];\n  }\n\n  return {\n    /**\n     * Getter for the key.\n     */\n    get key() {\n      return key;\n    },\n    /**\n     * Updates this with new settings\n     * @typedef settings\n     * @type {object}\n     * @property {string} [type] - The interaction type. Is 'hammer' for this component\n     * @property {boolean|function} [enable] - Should the interaction be enabled or not.\n     * This is only run when adding event handlers. In effect at startup, update or during on/off.\n     * It does not run during every event loop.\n     * @property {object} [events] - The keys in this object is the names of native events\n     * that should be added to the chart element and they should all point to function which\n     * will be the corresponding event handler.\n     */\n    set(newSettings) {\n      setDefaultSettings(newSettings);\n      removeAddedEvents();\n      if (isOn) {\n        addRecognizers();\n      }\n    },\n    /**\n     * Turns off interactions\n     */\n    off() {\n      isOn = false;\n      removeAddedEvents();\n    },\n    /**\n     * Turns off interactions\n     */\n    on() {\n      isOn = true;\n      if (hammerGestures.length === 0) {\n        addRecognizers();\n      }\n    },\n    /**\n     * Destroys and unbinds all event handlers\n     */\n    destroy() {\n      removeAddedEvents();\n      if (mc) {\n        mc.destroy();\n      }\n      mc = null;\n      instance = null;\n      settings = null;\n    }\n  };\n}\n\nexport default hammer;\n","import hammer from './hammer';\n\nexport default function initialize(picasso) {\n  picasso.interaction('hammer', hammer);\n}\n"],"names":["translateKnownTypes","getGestureType","type","hammer","chart","mediator","element","settings","instance","mc","key","hammerGestures","isOn","setDefaultSettings","newSettings","gestures","enable","undefined","addRecognizers","bind","forEach","gesture","options","Hammer","event","toLowerCase","Manager","add","keys","events","eventName","on","push","recognizeWith","get","split","filter","e","requireFailure","removeAddedEvents","off","remove","length","destroy","initialize","picasso","interaction"],"mappings":"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"}